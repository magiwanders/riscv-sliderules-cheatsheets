import { immediates } from "./immediates.mjs";

export const instructions = {
  // RV32I Base Instruction Set
  add: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = rs1 + rs2",
    description: "Addition",
    type: "R",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0110011, mask: 0b1111111 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      funct7: { value: 0b0000000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  sub: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = rs1 - rs2",
    description: "Subtraction",
    type: "R",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0110011, mask: 0b1111111 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      funct7: { value: 0b0100000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  xor: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = rs1 ^ rs2",
    description: "Bitwise XOR",
    type: "R",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0110011, mask: 0b1111111 },
      funct3: { value: 0b100, mask: 0b111 << 12 },
      funct7: { value: 0b0000000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  slt: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = { 31'b0, ( rs1[31] == rs2[31] ) ? (rs1<rs2) : (rs1[31])}",
    description: "Set Less Than",
    type: "R",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0110011, mask: 0b1111111 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      funct7: { value: 0b0000000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  or: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = rs1 | rs2",
    description: "Bitwise OR",
    type: "R",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0110011, mask: 0b1111111 },
      funct3: { value: 0b110, mask: 0b111 << 12 },
      funct7: { value: 0b0000000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  sll: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = rs1 <<(zero extends) rs2",
    description: "Shift Left Logical",
    type: "R",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0110011, mask: 0b1111111 },
      funct3: { value: 0b001, mask: 0b111 << 12 },
      funct7: { value: 0b0000000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  srl: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = rs1 (zero extends)>> rs2",
    description: "Shift Right Logical",
    type: "R",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0110011, mask: 0b1111111 },
      funct3: { value: 0b101, mask: 0b111 << 12 },
      funct7: { value: 0b0000000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  sra: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = rs1 (msb extends)>> rs2",
    description: "Shift Right Arithmetic",
    type: "R",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0110011, mask: 0b1111111 },
      funct3: { value: 0b101, mask: 0b111 << 12 },
      funct7: { value: 0b0100000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  sltu: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = { 31'b0, rs1 < rs2 }",
    description: "Set Less Than Unsigned",
    type: "R",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0110011, mask: 0b1111111 },
      funct3: { value: 0b011, mask: 0b111 << 12 },
      funct7: { value: 0b0000000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  and: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = rs1 & rs2",
    description: "Bitwise AND",
    type: "R",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0110011, mask: 0b1111111 },
      funct3: { value: 0b111, mask: 0b111 << 12 },
      funct7: { value: 0b0000000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  addi: {
    ISA: "RV",
    assembly: ["rd", "rs1", "imm"],
    pseudocode: "rd = rs1 + imm",
    description: "Add Immediate",
    type: "I",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0010011, mask: 0b1111111 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  slti: {
    ISA: "RV",
    assembly: ["rd", "rs1", "imm"],
    pseudocode: "rd = (rs1 < imm) ? 1 : 0",
    description: "Set Less Than Immediate",
    type: "I",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0010011, mask: 0b1111111 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  sltiu: {
    ISA: "RV",
    assembly: ["rd", "rs1", "imm"],
    pseudocode: "rd = (rs1 < imm) ? 1 : 0",
    description: "Set Less Than Immediate Unsigned",
    type: "I",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0010011, mask: 0b1111111 },
      funct3: { value: 0b011, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  xori: {
    ISA: "RV",
    assembly: ["rd", "rs1", "imm"],
    pseudocode: "rd = rs1 ^ imm",
    description: "Bitwise XOR Immediate",
    type: "I",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0010011, mask: 0b1111111 },
      funct3: { value: 0b100, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  ori: {
    ISA: "RV",
    assembly: ["rd", "rs1", "imm"],
    pseudocode: "rd = rs1 | imm",
    description: "Bitwise OR Immediate",
    type: "I",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0010011, mask: 0b1111111 },
      funct3: { value: 0b110, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  andi: {
    ISA: "RV",
    assembly: ["rd", "rs1", "imm"],
    pseudocode: "rd = rs1 & imm",
    description: "Bitwise AND Immediate",
    type: "I",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0010011, mask: 0b1111111 },
      funct3: { value: 0b111, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  lb: {
    ISA: "RV",
    assembly: ["rd", "rs1", "imm"],
    pseudocode: "rd = M[rs1 + imm]",
    description: "Load Byte",
    type: "I",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0000011, mask: 0b1111111 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  lh: {
    ISA: "RV",
    assembly: ["rd", "rs1", "imm"],
    pseudocode: "rd = M[rs1 + imm]",
    description: "Load Halfword",
    type: "I",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0000011, mask: 0b1111111 },
      funct3: { value: 0b001, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  lw: {
    ISA: "RV",
    assembly: ["rd", "rs1", "imm"],
    pseudocode: "rd = M[rs1 + imm]",
    description: "Load Word",
    type: "I",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0000011, mask: 0b1111111 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  lbu: {
    ISA: "RV",
    assembly: ["rd", "rs1", "imm"],
    pseudocode: "rd = M[rs1 + imm]",
    description: "Load Byte Unsigned",
    type: "I",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0000011, mask: 0b1111111 },
      funct3: { value: 0b100, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  lhu: {
    ISA: "RV",
    assembly: ["rd", "rs1", "imm"],
    pseudocode: "rd = M[rs1 + imm]",
    description: "Load Halfword Unsigned",
    type: "I",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0000011, mask: 0b1111111 },
      funct3: { value: 0b101, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  jalr: {
    ISA: "RV",
    assembly: ["rd", "rs1", "imm"],
    pseudocode: "rd = PC + 4; PC = (rs1 + imm) & ~1",
    description: "Jump and Link Register",
    type: "I",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b1100111, mask: 0b1111111 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  lui: {
    ISA: "RV",
    assembly: ["rd", "imm"],
    pseudocode: "rd = imm << 12",
    description: "Load Upper Immediate",
    type: "U",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0110111, mask: 0b1111111 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  auipc: {
    ISA: "RV",
    assembly: ["rd", "imm"],
    pseudocode: "rd = PC + imm",
    description: "Add Upper Immediate to PC",
    type: "U",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0010111, mask: 0b1111111 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  jal: {
    ISA: "RV",
    assembly: ["rd", "imm"],
    pseudocode: "rd = PC + 4; PC = PC + imm",
    description: "Jump and Link",
    type: "J",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b1101111, mask: 0b1111111 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  beq: {
    ISA: "RV",
    assembly: ["rs1", "rs2", "imm"],
    pseudocode: "if(rs1 == rs2) PC = PC + imm",
    description: "Branch Equal",
    type: "B",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b1100011, mask: 0b1111111 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
    },
  },
  bne: {
    ISA: "RV",
    assembly: ["rs1", "rs2", "imm"],
    pseudocode: "if(rs1 != rs2) PC = PC + imm",
    description: "Branch Not Equal",
    type: "B",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b1100011, mask: 0b1111111 },
      funct3: { value: 0b001, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
    },
  },
  blt: {
    ISA: "RV",
    assembly: ["rs1", "rs2", "imm"],
    pseudocode: "if(rs1 < rs2) PC = PC + imm",
    description: "Branch Less Than",
    type: "B",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b1100011, mask: 0b1111111 },
      funct3: { value: 0b100, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
    },
  },
  bge: {
    ISA: "RV",
    assembly: ["rs1", "rs2", "imm"],
    pseudocode: "if(rs1 >= rs2) PC = PC + imm",
    description: "Branch Greater Than or Equal",
    type: "B",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b1100011, mask: 0b1111111 },
      funct3: { value: 0b101, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
    },
  },
  bltu: {
    ISA: "RV",
    assembly: ["rs1", "rs2", "imm"],
    pseudocode: "if(rs1 < rs2) PC = PC + imm",
    description: "Branch Less Than Unsigned",
    type: "B",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b1100011, mask: 0b1111111 },
      funct3: { value: 0b110, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
    },
  },
  bgeu: {
    ISA: "RV",
    assembly: ["rs1", "rs2", "imm"],
    pseudocode: "if(rs1 >= rs2) PC = PC + imm",
    description: "Branch Greater Than or Equal Unsigned",
    type: "B",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b1100011, mask: 0b1111111 },
      funct3: { value: 0b111, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
    },
  },
  sb: {
    ISA: "RV",
    assembly: ["rs1", "rs2", "imm"],
    pseudocode: "Memory[rs1 + imm] = rs2[0:7]",
    description: "Store Byte",
    type: "S",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0100011, mask: 0b1111111 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
    },
  },
  sh: {
    ISA: "RV",
    assembly: ["rs1", "rs2", "imm"],
    pseudocode: "Memory[rs1 + imm] = rs2[0:15]",
    description: "Store Halfword",
    type: "S",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0100011, mask: 0b1111111 },
      funct3: { value: 0b001, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
    },
  },
  sw: {
    ISA: "RV",
    assembly: ["rs1", "rs2", "imm"],
    pseudocode: "Memory[rs1 + imm] = rs2",
    description: "Store Word",
    type: "S",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0100011, mask: 0b1111111 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
    },
  },
  slli: {
    ISA: "RV",
    assembly: ["rd", "rs1", "shamt"],
    pseudocode: "rd = rs1 << shamt",
    description: "Shift Left Logical Immediate",
    type: "I",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0010011, mask: 0b1111111 },
      funct3: { value: 0b001, mask: 0b111 << 12 },
      funct7: { value: 0b0000000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      shamt: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  srli: {
    ISA: "RV",
    assembly: ["rd", "rs1", "shamt"],
    pseudocode: "rd = rs1 >>> shamt",
    description: "Shift Right Logical Immediate",
    type: "I",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0010011, mask: 0b1111111 },
      funct3: { value: 0b101, mask: 0b111 << 12 },
      funct7: { value: 0b0000000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      shamt: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  srai: {
    ISA: "RV",
    assembly: ["rd", "rs1", "shamt"],
    pseudocode: "rd = rs1 >> shamt",
    description: "Shift Right Arithmetic Immediate",
    type: "I",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0010011, mask: 0b1111111 },
      funct3: { value: 0b101, mask: 0b111 << 12 },
      funct7: { value: 0b0100000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      shamt: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fence: {
    ISA: "RV",
    assembly: ["pred", "succ"],
    pseudocode: "Fence(pred, succ)",
    description: "Synchronize",
    type: "I",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b0001111, mask: 0b1111111 },
      rd: { mask: 0b11111 << 7 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      succ: { mask: 0b1111 << 20 },
      pred: { mask: 0b1111 << 24 },
      fm: { mask: 0b1111 << 28 },
    },
  },
  ecall: {
    ISA: "RV",
    assembly: ["ecall"],
    pseudocode: "ECALL",
    description: "Environment Call",
    type: "I",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b1110011, mask: 0b1111111 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      rd: { value: 0b00000, mask: 0b11111 << 7 },
      rs1: { value: 0b00000, mask: 0b11111 << 15 },
      funct12: { value: 0b000000000000, mask: 0b111111111111 << 20 },
    },
  },
  ebreak: {
    ISA: "RV",
    assembly: ["ebreak"],
    pseudocode: "EBREAK",
    description: "Environment Breakpoint",
    type: "I",
    arch_width: [32, 64],
    extension: "I",
    fields: {
      opcode: { value: 0b1110011, mask: 0b1111111 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      rd: { value: 0b00000, mask: 0b11111 << 7 },
      rs1: { value: 0b00000, mask: 0b11111 << 15 },
      funct12: { value: 0b000000000001, mask: 0b111111111111 << 20 },
    },
  },
  // RV64I Base Instruction Set (in addition to RV32I)
  lwu: {
    ISA: "RV",
    assembly: ["rd", "imm(rs1)"],
    pseudocode: "rd = M[rs1 + imm]",
    description: "Load Word Unsigned",
    type: "I",
    arch_width: [64],
    extension: "I",
    fields: {
      opcode: { value: 0b0000011, mask: 0b1111111 },
      funct3: { value: 0b110, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  ld: {
    ISA: "RV",
    assembly: ["rd", "imm(rs1)"],
    pseudocode: "rd = M[rs1 + imm]",
    description: "Load Doubleword",
    type: "I",
    arch_width: [64],
    extension: "I",
    fields: {
      opcode: { value: 0b0000011, mask: 0b1111111 },
      funct3: { value: 0b011, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  sd: {
    ISA: "RV",
    assembly: ["rs2", "imm(rs1)"],
    pseudocode: "M[rs1 + imm] = rs2",
    description: "Store Doubleword",
    type: "S",
    arch_width: [64],
    extension: "I",
    fields: {
      opcode: { value: 0b0100011, mask: 0b1111111 },
      funct3: { value: 0b011, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
    },
  },
  slli64: {
    ISA: "RV",
    assembly: ["rd", "rs1", "shamt"],
    pseudocode: "rd = rs1 << shamt",
    description: "Shift Left Logical Immediate (64-bit)",
    type: "I",
    arch_width: [64],
    extension: "I",
    fields: {
      opcode: { value: 0b0010011, mask: 0b1111111 },
      funct3: { value: 0b001, mask: 0b111 << 12 },
      imm: { value: 0b00000, mask: 0b1111111 << 26 },
      rs1: { mask: 0b11111 << 15 },
      shamt: { mask: 0b111111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  srli64: {
    ISA: "RV",
    assembly: ["rd", "rs1", "shamt"],
    pseudocode: "rd = rs1 >> shamt (logical)",
    description: "Shift Right Logical Immediate (64-bit)",
    type: "I",
    arch_width: [64],
    extension: "I",
    fields: {
      opcode: { value: 0b0010011, mask: 0b1111111 },
      funct3: { value: 0b101, mask: 0b111 << 12 },
      imm: { value: 0b00000, mask: 0b1111111 << 26 },
      rs1: { mask: 0b11111 << 15 },
      shamt: { mask: 0b111111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  srai64: {
    ISA: "RV",
    assembly: ["rd", "rs1", "shamt"],
    pseudocode: "rd = rs1 >> shamt (arithmetic)",
    description: "Shift Right Arithmetic Immediate (64-bit)",
    type: "I",
    arch_width: [64],
    extension: "I",
    fields: {
      opcode: { value: 0b0010011, mask: 0b1111111 },
      funct3: { value: 0b101, mask: 0b111 << 12 },
      imm: { value: 0b010000, mask: 0b1111111 << 26 },
      rs1: { mask: 0b11111 << 15 },
      shamt: { mask: 0b111111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  addiw: {
    ISA: "RV",
    assembly: ["rd", "rs1", "imm"],
    pseudocode: "rd = rs1 + imm (signed immediate)",
    description: "Add Immediate (64-bit)",
    type: "I",
    arch_width: [64],
    extension: "I",
    fields: {
      opcode: { value: 0b0011011, mask: 0b1111111 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  slliw: {
    ISA: "RV",
    assembly: ["rd", "rs1", "shamt"],
    pseudocode: "rd = rs1 << shamt (64-bit)",
    description: "Shift Left Logical Immediate (64-bit)",
    type: "I",
    arch_width: [64],
    extension: "I",
    fields: {
      opcode: { value: 0b0011011, mask: 0b1111111 },
      funct3: { value: 0b001, mask: 0b111 << 12 },
      funct7: { value: 0b0000000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      shamt: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  srliw: {
    ISA: "RV",
    assembly: ["rd", "rs1", "shamt"],
    pseudocode: "rd = rs1 >> shamt (logical, 64-bit)",
    description: "Shift Right Logical Immediate (64-bit)",
    type: "I",
    arch_width: [64],
    extension: "I",
    fields: {
      opcode: { value: 0b0011011, mask: 0b1111111 },
      funct3: { value: 0b101, mask: 0b111 << 12 },
      funct7: { value: 0b0000000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      shamt: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  sraiw: {
    ISA: "RV",
    assembly: ["rd", "rs1", "shamt"],
    pseudocode: "rd = rs1 >> shamt (arithmetic, 64-bit)",
    description: "Shift Right Arithmetic Immediate (64-bit)",
    type: "I",
    arch_width: [64],
    extension: "I",
    fields: {
      opcode: { value: 0b0011011, mask: 0b1111111 },
      funct3: { value: 0b101, mask: 0b101 << 12 },
      funct7: { value: 0b0100000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      shamt: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  addw: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = rs1 + rs2 (64-bit)",
    description: "Add (64-bit)",
    type: "R",
    arch_width: [64],
    extension: "I",
    fields: {
      opcode: { value: 0b0111011, mask: 0b1111111 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      funct7: { value: 0b0000000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  subw: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = rs1 - rs2 (64-bit)",
    description: "Subtract (64-bit)",
    type: "R",
    arch_width: [64],
    extension: "I",
    fields: {
      opcode: { value: 0b0111011, mask: 0b1111111 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      funct7: { value: 0b0100000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  sllw: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = rs1 << rs2 (64-bit)",
    description: "Shift Left Logical (64-bit)",
    type: "R",
    arch_width: [64],
    extension: "I",
    fields: {
      opcode: { value: 0b0111011, mask: 0b1111111 },
      funct3: { value: 0b001, mask: 0b111 << 12 },
      funct7: { value: 0b0000000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  srlw: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = rs1 >> rs2 (logical, 64-bit)",
    description: "Shift Right Logical (64-bit)",
    type: "R",
    arch_width: [64],
    extension: "I",
    fields: {
      opcode: { value: 0b0111011, mask: 0b1111111 },
      funct3: { value: 0b101, mask: 0b111 << 12 },
      funct7: { value: 0b0000000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  sraw: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = rs1 >> rs2 (arithmetic, 64-bit)",
    description: "Shift Right Arithmetic (64-bit)",
    type: "R",
    arch_width: [64],
    extension: "I",
    fields: {
      opcode: { value: 0b0111011, mask: 0b1111111 },
      funct3: { value: 0b101, mask: 0b101 << 12 },
      funct7: { value: 0b0100000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  // RV32/RV64 Zifencei Standard Extension
  fence_i: {
    ISA: "RV",
    assembly: ["imm", "rs1"],
    pseudocode: "fence",
    description: "Fence for instruction stream",
    type: "I",
    arch_width: [32, 64],
    extension: "Zifencei",
    fields: {
      opcode: { value: 0b0001111, mask: 0b1111111 },
      funct3: { value: 0b001, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  // RV32/RV64 Zicsr Standard Extension
  csrrw: {
    ISA: "RV",
    assembly: ["csr", "rd", "rs1"],
    pseudocode: "rd = CSRs[csr]; CSRs[csr] = rs1",
    description: "Atomic Read and Write of CSR",
    type: "I",
    arch_width: [32, 64],
    extension: "Zicsr",
    fields: {
      opcode: { value: 0b1110011, mask: 0b1111111 },
      funct3: { value: 0b001, mask: 0b111 << 12 },
      csr: { mask: 0b111111111111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  csrrs: {
    ISA: "RV",
    assembly: ["csr", "rd", "rs1"],
    pseudocode: "rd = CSRs[csr]; CSRs[csr] = CSRs[csr] | rs1",
    description: "Atomic Read and Set of CSR Bits",
    type: "I",
    arch_width: [32, 64],
    extension: "Zicsr",
    fields: {
      opcode: { value: 0b1110011, mask: 0b1111111 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      csr: { mask: 0b111111111111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  csrrc: {
    ISA: "RV",
    assembly: ["csr", "rd", "rs1"],
    pseudocode: "rd = CSRs[csr]; CSRs[csr] = CSRs[csr] & (~rs1)",
    description: "Atomic Read and Clear of CSR Bits",
    type: "I",
    arch_width: [32, 64],
    extension: "Zicsr",
    fields: {
      opcode: { value: 0b1110011, mask: 0b1111111 },
      funct3: { value: 0b011, mask: 0b111 << 12 },
      csr: { mask: 0b111111111111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  csrrwi: {
    ISA: "RV",
    assembly: ["uimm", "rd", "csr"],
    pseudocode: "rd = CSRs[csr]; CSRs[csr] = uimm",
    description: "Atomic Read and Write of CSR with Immediate",
    type: "I",
    arch_width: [32, 64],
    extension: "Zicsr",
    fields: {
      opcode: { value: 0b1110011, mask: 0b1111111 },
      funct3: { value: 0b101, mask: 0b111 << 12 },
      csr: { mask: 0b111111111111 << 20 },
      uimm: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  csrrsi: {
    ISA: "RV",
    assembly: ["uimm", "rd", "csr"],
    pseudocode: "rd = CSRs[csr]; CSRs[csr] = CSRs[csr] | uimm",
    description: "Atomic Read and Set of CSR Bits with Immediate",
    type: "I",
    arch_width: [32, 64],
    extension: "Zicsr",
    fields: {
      opcode: { value: 0b1110011, mask: 0b1111111 },
      funct3: { value: 0b110, mask: 0b111 << 12 },
      csr: { mask: 0b111111111111 << 20 },
      uimm: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  csrrci: {
    ISA: "RV",
    assembly: ["uimm", "rd", "csr"],
    pseudocode: "rd = CSRs[csr]; CSRs[csr] = CSRs[csr] & (~uimm)",
    description: "Atomic Read and Clear of CSR Bits with Immediate",
    type: "I",
    arch_width: [32, 64],
    extension: "Zicsr",
    fields: {
      opcode: { value: 0b1110011, mask: 0b1111111 },
      funct3: { value: 0b111, mask: 0b111 << 12 },
      csr: { mask: 0b111111111111 << 20 },
      uimm: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  //RV32M Standard Extension
  mul: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = rs1 * rs2",
    description: "Multiply",
    type: "R",
    arch_width: [32, 64],
    extension: "M",
    fields: {
      opcode: { value: 0b0110011, mask: 0b1111111 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      funct7: { value: 0b0000001, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  mulh: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = (rs1 * rs2) >> XLEN",
    description: "Multiply High",
    type: "R",
    arch_width: [32, 64],
    extension: "M",
    fields: {
      opcode: { value: 0b0110011, mask: 0b1111111 },
      funct3: { value: 0b001, mask: 0b111 << 12 },
      funct7: { value: 0b0000001, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  mulhsu: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = (rs1 * rs2) >> XLEN",
    description: "Multiply High Signed Unsigned",
    type: "R",
    arch_width: [32, 64],
    extension: "M",
    fields: {
      opcode: { value: 0b0110011, mask: 0b1111111 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      funct7: { value: 0b0000001, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  mulhu: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = (rs1 * rs2) >> XLEN",
    description: "Multiply High Unsigned",
    type: "R",
    arch_width: [32, 64],
    extension: "M",
    fields: {
      opcode: { value: 0b0110011, mask: 0b1111111 },
      funct3: { value: 0b011, mask: 0b111 << 12 },
      funct7: { value: 0b0000001, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  div: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = rs1 / rs2",
    description: "Divide",
    type: "R",
    arch_width: [32, 64],
    extension: "M",
    fields: {
      opcode: { value: 0b0110011, mask: 0b1111111 },
      funct3: { value: 0b100, mask: 0b111 << 12 },
      funct7: { value: 0b0000001, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  divu: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = rs1 / rs2",
    description: "Divide Unsigned",
    type: "R",
    arch_width: [32, 64],
    extension: "M",
    fields: {
      opcode: { value: 0b0110011, mask: 0b1111111 },
      funct3: { value: 0b101, mask: 0b111 << 12 },
      funct7: { value: 0b0000001, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  rem: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = rs1 % rs2",
    description: "Remainder",
    type: "R",
    arch_width: [32, 64],
    extension: "M",
    fields: {
      opcode: { value: 0b0110011, mask: 0b1111111 },
      funct3: { value: 0b110, mask: 0b111 << 12 },
      funct7: { value: 0b0000001, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  remu: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = rs1 % rs2",
    description: "Remainder Unsigned",
    type: "R",
    arch_width: [32, 64],
    extension: "M",
    fields: {
      opcode: { value: 0b0110011, mask: 0b1111111 },
      funct3: { value: 0b111, mask: 0b111 << 12 },
      funct7: { value: 0b0000001, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  // RV64M Standard Extension (in addition to RV32M)
  mulw: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode:
      "rd = rs1 * rs2 (signed 64x64-bit multiplication, result stored in 64-bit rd)",
    description: "Multiply Word",
    type: "R",
    arch_width: [64],
    extension: "M",
    fields: {
      opcode: { value: 0b0111011, mask: 0b1111111 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      funct7: { value: 0b0000001, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  divw: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode:
      "rd = rs1 / rs2 (signed 64/64-bit division, quotient stored in 64-bit rd)",
    description: "Divide Word",
    type: "R",
    arch_width: [64],
    extension: "M",
    fields: {
      opcode: { value: 0b0111011, mask: 0b1111111 },
      funct3: { value: 0b100, mask: 0b111 << 12 },
      funct7: { value: 0b0000001, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  divuw: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode:
      "rd = rs1 / rs2 (unsigned 64/64-bit division, quotient stored in 64-bit rd)",
    description: "Divide Unsigned Word",
    type: "R",
    arch_width: [64],
    extension: "M",
    fields: {
      opcode: { value: 0b0111011, mask: 0b1111111 },
      funct3: { value: 0b101, mask: 0b111 << 12 },
      funct7: { value: 0b0000001, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  remw: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode:
      "rd = rs1 % rs2 (signed 64/64-bit remainder, result stored in 64-bit rd)",
    description: "Remainder Word",
    type: "R",
    arch_width: [64],
    extension: "M",
    fields: {
      opcode: { value: 0b0111011, mask: 0b1111111 },
      funct3: { value: 0b110, mask: 0b111 << 12 },
      funct7: { value: 0b0000001, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  remuw: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode:
      "rd = rs1 % rs2 (unsigned 64/64-bit remainder, result stored in 64-bit rd)",
    description: "Remainder Unsigned Word",
    type: "R",
    arch_width: [64],
    extension: "M",
    fields: {
      opcode: { value: 0b0111011, mask: 0b1111111 },
      funct3: { value: 0b111, mask: 0b111 << 12 },
      funct7: { value: 0b0000001, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  // RV32A Standard Extension
  lr_w: {
    ISA: "RV",
    assembly: ["rd", "rs1", "aq", "rl"],
    pseudocode: "rd = M[rs1]; if aq then aq = 0; if rl then rl = 0;",
    description: "Load Reserved (Word)",
    type: "R",
    arch_width: [32, 64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      funct5: { value: 0b00010, mask: 0b11111 << 27 },
      rs2: { value: 0b00000, mask: 0b11111 << 20 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  sc_w: {
    ISA: "RV",
    assembly: ["rd", "rs1", "aq", "rl", "rs2"],
    pseudocode:
      "rd = M[rs1]; if aq then aq = 0; if rl then rl = 0; if successful SC, rd = 0; else rd = 1;",
    description: "Store Conditional (Word)",
    type: "R",
    arch_width: [32, 64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      funct5: { value: 0b00011, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  amoswap_w: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode:
      "rd = M[rs1]; if aq then aq = 0; if rl then rl = 0; M[rs1] = rs2;",
    description: "Atomic Swap (Word)",
    type: "R",
    arch_width: [32, 64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      funct5: { value: 0b00001, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  amoadd_w: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = Memory[rs1]; Memory[rs1] = rd + rs2;",
    description: "Atomic Add Word",
    type: "R",
    arch_width: [32, 64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      funct5: { value: 0b00000, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  amoxor_w: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = Memory[rs1]; Memory[rs1] = rd ^ rs2;",
    description: "Atomic XOR Word",
    type: "R",
    arch_width: [32, 64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      funct5: { value: 0b00100, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  amoand_w: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = Memory[rs1]; Memory[rs1] = rd & rs2;",
    description: "Atomic AND Word",
    type: "R",
    arch_width: [32, 64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      funct5: { value: 0b01100, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  amoor_w: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = Memory[rs1]; Memory[rs1] = rd | rs2;",
    description: "Atomic OR Word",
    type: "R",
    arch_width: [32, 64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      funct5: { value: 0b01000, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  amomin_w: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = Memory[rs1]; Memory[rs1] = min(rd, rs2);",
    description: "Atomic Minimum Word",
    type: "R",
    arch_width: [32, 64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      funct5: { value: 0b10000, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  amomax_w: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = Memory[rs1]; Memory[rs1] = max(rd, rs2);",
    description: "Atomic Maximum Word",
    type: "R",
    arch_width: [32, 64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      funct5: { value: 0b10100, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  amominu_w: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = Memory[rs1]; Memory[rs1] = minu(rd, rs2);",
    description: "Atomic Minimum Unsigned Word",
    type: "R",
    arch_width: [32, 64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      funct5: { value: 0b11000, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  amomaxu_w: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = Memory[rs1]; Memory[rs1] = maxu(rd, rs2);",
    description: "Atomic Maximum Unsigned Word",
    type: "R",
    arch_width: [32, 64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      funct5: { value: 0b11100, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  // RV64A Standard Extension (in addition to RV32A)
  lr_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = Memory[rs1];",
    description: "Load Reserved Doubleword",
    type: "R",
    arch_width: [64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b011, mask: 0b111 << 12 },
      funct5: { value: 0b00010, mask: 0b11111 << 27 },
      rs2: { value: 0b00000, mask: 0b11111 << 20 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  sc_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode:
      "if (Memory[rs1] == rd) { Memory[rs1] = rs2; rd = 1; } else rd = 0;",
    description: "Store Conditional Doubleword",
    type: "R",
    arch_width: [64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b011, mask: 0b111 << 12 },
      funct5: { value: 0b00011, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  amoswap_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = Memory[rs1]; Memory[rs1] = rs2;",
    description: "Atomic Swap Doubleword",
    type: "R",
    arch_width: [64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b011, mask: 0b111 << 12 },
      funct5: { value: 0b00001, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  amoadd_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = Memory[rs1]; Memory[rs1] = rd + rs2;",
    description: "Atomic Add Double",
    type: "R",
    arch_width: [64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b011, mask: 0b111 << 12 },
      funct5: { value: 0b00001, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  amoxor_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = Memory[rs1]; Memory[rs1] = rd ^ rs2;",
    description: "Atomic XOR Double",
    type: "R",
    arch_width: [64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b011, mask: 0b111 << 12 },
      funct5: { value: 0b00100, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  amoand_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = Memory[rs1]; Memory[rs1] = rd & rs2;",
    description: "Atomic AND Double",
    type: "R",
    arch_width: [64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b011, mask: 0b111 << 12 },
      funct5: { value: 0b01100, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  amoor_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = Memory[rs1]; Memory[rs1] = rd | rs2;",
    description: "Atomic OR Double",
    type: "R",
    arch_width: [64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b011, mask: 0b111 << 12 },
      funct5: { value: 0b01000, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  amomin_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = Memory[rs1]; Memory[rs1] = min(rd, rs2);",
    description: "Atomic Minimum Double",
    type: "R",
    arch_width: [64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b011, mask: 0b111 << 12 },
      funct5: { value: 0b10000, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  amomax_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = Memory[rs1]; Memory[rs1] = max(rd, rs2);",
    description: "Atomic Maximum Double",
    type: "R",
    arch_width: [64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b011, mask: 0b111 << 12 },
      funct5: { value: 0b10100, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  amominu_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = Memory[rs1]; Memory[rs1] = min(rd, rs2);",
    description: "Atomic Minimum Unsigned Double",
    type: "R",
    arch_width: [64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b011, mask: 0b111 << 12 },
      funct5: { value: 0b11000, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  amomaxu_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = Memory[rs1]; Memory[rs1] = max(rd, rs2);",
    description: "Atomic Maximum Unsigned Double",
    type: "R",
    arch_width: [64],
    extension: "A",
    fields: {
      opcode: { value: 0b0101111, mask: 0b1111111 },
      funct3: { value: 0b011, mask: 0b111 << 12 },
      funct5: { value: 0b11100, mask: 0b11111 << 27 },
      aq: { mask: 0b1 << 26 },
      rl: { mask: 0b1 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  // RV32F Standard Extension
  flw: {
    ISA: "RV",
    assembly: ["rd", "rs1", "imm"],
    pseudocode: "f(rd) = Memory[rs1 + imm];",
    description: "Load Floating-Point Word",
    type: "I",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b0000111, mask: 0b1111111 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fsw: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2", "imm"],
    pseudocode: "Memory[rs1 + imm] = f(rs2);",
    description: "Store Floating-Point Word",
    type: "S",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b0100111, mask: 0b1111111 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
    },
  },
  fmadd_s: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2", "rs3"],
    pseudocode: "f(rd) = f(rs1) * f(rs2) + f(rs3);",
    description: "Floating-Point Multiply-Add Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1000011, mask: 0b1111111 },
      funct2: { value: 0b00, mask: 0b11 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rs3: { mask: 0b11111 << 27 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fmsub_s: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2", "rs3"],
    pseudocode: "f(rd) = f(rs1) * f(rs2) - f(rs3);",
    description: "Floating-Point Multiply-Subtract Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1000111, mask: 0b1111111 },
      funct2: { value: 0b00, mask: 0b11 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rs3: { mask: 0b11111 << 27 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fnmsub_s: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2", "rs3"],
    pseudocode: "f(rd) = -f(rs1) * f(rs2) - f(rs3);",
    description: "Floating-Point Negate-Multiply-Subtract Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1001011, mask: 0b1111111 },
      funct2: { value: 0b00, mask: 0b11 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rs3: { mask: 0b11111 << 27 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fnmadd_s: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2", "rs3"],
    pseudocode: "f(rd) = -f(rs1) * f(rs2) + f(rs3);",
    description: "Floating-Point Negate-Multiply-Add Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1001111, mask: 0b1111111 },
      funct2: { value: 0b00, mask: 0b11 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rs3: { mask: 0b11111 << 27 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fadd_s: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "f(rd) = f(rs1) + f(rs2);",
    description: "Floating-Point Add Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0000000, mask: 0b1111111 << 25 },
      rm: { mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fsub_s: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "f(rd) = f(rs1) - f(rs2);",
    description: "Floating-Point Subtract Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0000100, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fmul_s: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "f(rd) = f(rs1) * f(rs2);",
    description: "Floating-Point Multiply Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0001000, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fdiv_s: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "f(rd) = f(rs1) / f(rs2);",
    description: "Floating-Point Divide Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0001100, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fsqrt_s: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "f(rd) = sqrt(f(rs1));",
    description: "Floating-Point Square Root Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0101100, mask: 0b1111111 << 25 },
      rs2: { value: 0b00000, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fsgnj_s: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "f(rd) = f(rs1) with sign of f(rs2);",
    description: "Floating-Point Sign Inject Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0010000, mask: 0b1111111 << 25 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fsgnjn_s: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "f(rd) = f(rs1) with sign of -f(rs2);",
    description: "Floating-Point Sign Inject Negate Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0010000, mask: 0b1111111 << 25 },
      funct3: { value: 0b001, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fsgnjx_s: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "f(rd) = f(rs1) with sign of f(rs2), and value of abs(f(rs1));",
    description: "Floating-Point Sign Inject with Exchange Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0010000, mask: 0b1111111 << 25 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fmin_s: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "f(rd) = min(f(rs1), f(rs2));",
    description: "Floating-Point Minimum Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0010100, mask: 0b1111111 << 25 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fmax_s: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "f(rd) = max(f(rs1), f(rs2));",
    description: "Floating-Point Maximum Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0010100, mask: 0b1111111 << 25 },
      funct3: { value: 0b001, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fcvt_w_s: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = (int32_t)f(rs1);",
    description: "Floating-Point Convert to Signed Word Single Precision",
    type: "R4",
    arch_width: [32],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1100000, mask: 0b1111111 << 25 },
      rs2: { value: 0b00000, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fcvt_wu_s: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = (uint32_t)f(rs1);",
    description: "Floating-Point Convert to Unsigned Word Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1100000, mask: 0b1111111 << 25 },
      rs2: { value: 0b00001, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fmv_x_w: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = rs1;",
    description: "Floating-Point Move to Integer Register Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1110000, mask: 0b1111111 << 25 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      rs2: { value: 0b00000, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  feq_s: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = (f(rs1) == f(rs2)) ? 1 : 0;",
    description: "Floating-Point Equal Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1010000, mask: 0b1111111 << 25 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  flt_s: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = (f(rs1) < f(rs2)) ? 1 : 0;",
    description: "Floating-Point Less Than Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1010000, mask: 0b1111111 << 25 },
      funct3: { value: 0b001, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fle_s: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = (f(rs1) <= f(rs2)) ? 1 : 0;",
    description: "Floating-Point Less Than or Equal Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1010000, mask: 0b1111111 << 25 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fclass_s: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = fclass_s(rs1);",
    description: "Floating-Point Classify Single Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1110000, mask: 0b1111111 << 25 },
      funct3: { value: 0b001, mask: 0b111 << 12 },
      rs2: { value: 0b00000, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fcvt_s_w: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = f32_to_i32(rs1, RM, true);",
    description: "Floating-Point Convert to Signed Word Single Precision",
    type: "R4",
    arch_width: [32],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1101000, mask: 0b1111111 << 25 },
      rs2: { value: 0b00000, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fcvt_s_wu: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = f32_to_ui32(rs1, RM, true);",
    description: "Floating-Point Convert to Unsigned Word Single Precision",
    type: "R4",
    arch_width: [32],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1101000, mask: 0b1111111 << 25 },
      rs2: { value: 0b00001, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fmv_w_x: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = rs1;",
    description: "Floating-Point Move to Integer Register Single Precision",
    type: "R4",
    arch_width: [32],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1111000, mask: 0b1111111 << 25 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      rs2: { value: 0b00000, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  // RV64F Standard Extension (in addition to RV32F)
  fcvt_l_s: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = f64_to_i64(rs1, RM, true);",
    description: "Floating-Point Convert to Signed Long Double Precision",
    type: "R4",
    arch_width: [64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1100000, mask: 0b1111111 << 25 },
      rs2: { value: 0b00010, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fcvt_lu_s: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = f64_to_ui64(rs1, RM, true);",
    description: "Floating-Point Convert to Unsigned Long Double Precision",
    type: "R4",
    arch_width: [64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1100000, mask: 0b1111111 << 25 },
      rs2: { value: 0b00011, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fcvt_s_l: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = f64_to_f32(rs1, RM);",
    description:
      "Floating-Point Convert to Single Precision from Long Double Precision",
    type: "R4",
    arch_width: [64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1101000, mask: 0b1111111 << 25 },
      rs2: { value: 0b00010, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fcvt_s_lu: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = f64_to_f32(rs1, RM);",
    description:
      "Floating-Point Convert to Single Precision from Unsigned Long Double Precision",
    type: "R4",
    arch_width: [64],
    extension: "F",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1101000, mask: 0b1111111 << 25 },
      rs2: { value: 0b00011, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  // RV32D Standard Extension
  fld: {
    ISA: "RV",
    assembly: ["rd", "rs1", "imm"],
    pseudocode: "rd = Memory[rs1 + imm];",
    description: "Floating-Point Load Double Precision",
    type: "I",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b0000111, mask: 0b1111111 },
      funct3: { value: 0b011, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fsd: {
    ISA: "RV",
    assembly: ["rs1", "rs2", "imm"],
    pseudocode: "Memory[rs1 + imm] = rs2;",
    description: "Floating-Point Store Double Precision",
    type: "S",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b0100111, mask: 0b1111111 },
      funct3: { value: 0b011, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
    },
  },
  fmadd_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2", "rs3"],
    pseudocode: "rd = f64_mulAdd(rs1, rs2, rs3, RM);",
    description: "Floating-Point Multiply-Add Double Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1000011, mask: 0b1111111 },
      funct2: { value: 0b01, mask: 0b11 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rs3: { mask: 0b11111 << 27 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fmsub_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2", "rs3"],
    pseudocode: "rd = f64_mulAdd(rs1, rs2, rs3, RM);",
    description: "Floating-Point Multiply-Subtract Double Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1000111, mask: 0b1111111 },
      funct2: { value: 0b01, mask: 0b11 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rs3: { mask: 0b11111 << 27 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fnmsub_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2", "rs3"],
    pseudocode: "rd = -f64_mulAdd(rs1, rs2, rs3, RM);",
    description: "Floating-Point Negate-Multiply-Subtract Double Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1001011, mask: 0b1111111 },
      funct2: { value: 0b01, mask: 0b11 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rs3: { mask: 0b11111 << 27 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fnmadd_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2", "rs3"],
    pseudocode: "rd = -f64_mulAdd(rs1, rs2, rs3, RM);",
    description: "Floating-Point Negate-Multiply-Add Double Precision",
    type: "R4",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1001111, mask: 0b1111111 },
      funct2: { value: 0b01, mask: 0b11 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rs3: { mask: 0b11111 << 27 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fadd_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = f64_add(rs1, rs2, RM);",
    description: "Floating-Point Add Double Precision",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0000001, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fsub_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = f64_sub(rs1, rs2, RM);",
    description: "Floating-Point Subtract Double Precision",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0000101, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fmul_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = f64_mul(rs1, rs2, RM);",
    description: "Floating-Point Multiply Double Precision",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0001001, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fdiv_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = f64_div(rs1, rs2, RM);",
    description: "Floating-Point Divide Double Precision",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0001101, mask: 0b1111111 << 25 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fsqrt_d: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = sqrt(f(rs1));",
    description: "Floating-Point Divide Double Precision",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0101101, mask: 0b1111111 << 25 },
      rs2: { value: 0b00000, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fsgnj_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = f64_gnj(rs1, rs2, false);",
    description: "Floating-Point Sign Injection Double Precision",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0010001, mask: 0b1111111 << 25 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fsgnjn_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = f64_gnj(rs1, rs2, true);",
    description: "Floating-Point Sign Injection (Negate) Double Precision",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0010001, mask: 0b1111111 << 25 },
      funct3: { value: 0b001, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fsgnjx_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = f64_gnjn(rs1, rs2);",
    description: "Floating-Point Sign Injection (XOR) Double Precision",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0010001, mask: 0b1111111 << 25 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fmin_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = f64_min(rs1, rs2);",
    description: "Floating-Point Minimum Double Precision",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0010101, mask: 0b1111111 << 25 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fmax_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = f64_max(rs1, rs2);",
    description: "Floating-Point Maximum Double Precision",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0010101, mask: 0b1111111 << 25 },
      funct3: { value: 0b001, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fcvt_s_d: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = f32_to_f64(rs1, RM);",
    description:
      "Floating-Point Convert to Single Precision from Double Precision",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0100000, mask: 0b1111111 << 25 },
      rs2: { value: 0b00001, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fcvt_d_s: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = f64_to_f32(rs1, RM);",
    description:
      "Floating-Point Convert to Double Precision from Single Precision",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b0100001, mask: 0b1111111 << 25 },
      rs2: { value: 0b00000, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  feq_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = f64_eq(rs1, rs2);",
    description: "Floating-Point Equality Double Precision",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1010001, mask: 0b1111111 << 25 },
      funct3: { value: 0b010, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  flt_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = f64_lt(rs1, rs2);",
    description: "Floating-Point Less Than Double Precision",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1010001, mask: 0b1111111 << 25 },
      funct3: { value: 0b001, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fle_d: {
    ISA: "RV",
    assembly: ["rd", "rs1", "rs2"],
    pseudocode: "rd = f64_le(rs1, rs2);",
    description: "Floating-Point Less Than or Equal Double Precision",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1010001, mask: 0b1111111 << 25 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rs2: { mask: 0b11111 << 20 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fclass_d: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = f64_classify(rs1);",
    description: "Floating-Point Classify Double Precision",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1110001, mask: 0b1111111 << 25 },
      rs2: { value: 0b00000, mask: 0b11111 << 20 },
      funct3: { value: 0b001, mask: 0b111 << 12 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fcvt_w_d: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = f64_to_i32(rs1, RM, true);",
    description: "Floating-Point Convert to Signed Word Double Precision",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1100001, mask: 0b1111111 << 25 },
      rs2: { value: 0b00000, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fcvt_wu_d: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = f64_to_ui32(rs1, RM, true);",
    description: "Floating-Point Convert to Unsigned Word Double Precision",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1100001, mask: 0b1111111 << 25 },
      rs2: { value: 0b00001, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fcvt_d_w: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = i32_to_f64(rs1, RM);",
    description: "Floating-Point Convert to Double Precision from Signed Word",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1101001, mask: 0b1111111 << 25 },
      rs2: { value: 0b00000, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fcvt_d_wu: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = ui32_to_f64(rs1, RM);",
    description:
      "Floating-Point Convert to Double Precision from Unsigned Word",
    type: "R",
    arch_width: [32, 64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1101001, mask: 0b1111111 << 25 },
      rs2: { value: 0b00001, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  // RV64D Standard Extension (in addition to RV32D)
  fcvt_l_d: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = f64_to_i64(rs1, RM, true);",
    description: "Floating-Point Convert to Signed Long Double Precision",
    type: "R",
    arch_width: [64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1100001, mask: 0b1111111 << 25 },
      rs2: { value: 0b00010, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fcvt_lu_d: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = f64_to_ui64(rs1, RM, true);",
    description: "Floating-Point Convert to Unsigned Long Double Precision",
    type: "R",
    arch_width: [64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1100001, mask: 0b1111111 << 25 },
      rs2: { value: 0b00011, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fmv_x_d: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = rs1;",
    description: "Floating-Point Move Double Precision",
    type: "R",
    arch_width: [64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1110001, mask: 0b1111111 << 25 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      rs2: { value: 0b00000, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  fcvt_d_l: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = i64_to_f64(rs1, RM);",
    description: "Floating-Point Convert to Double Precision from Signed Long",
    type: "R",
    arch_width: [64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1101001, mask: 0b1111111 << 25 },
      rs2: { value: 0b00010, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fcvt_d_lu: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = ui64_to_f64(rs1, RM);",
    description:
      "Floating-Point Convert to Double Precision from Unsigned Long",
    type: "R",
    arch_width: [64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1101001, mask: 0b1111111 << 25 },
      rs2: { value: 0b00011, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
      rm: { mask: 0b111 << 12 },
    },
  },
  fmv_d_x: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "rd = rs1;",
    description: "Floating-Point Move Double Precision",
    type: "R",
    arch_width: [64],
    extension: "D",
    fields: {
      opcode: { value: 0b1010011, mask: 0b1111111 },
      funct7: { value: 0b1111001, mask: 0b1111111 << 25 },
      funct3: { value: 0b000, mask: 0b111 << 12 },
      rs2: { value: 0b00000, mask: 0b11111 << 20 },
      rs1: { mask: 0b11111 << 15 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  //RV32C Standard Extension
  illegal_instruction: {
    ISA: "RV",
    assembly: ["imm"],
    pseudocode: "Raise an illegal instruction exception;",
    description: "Illegal Instruction",
    type: "CI",
    arch_width: [32,64],
    extension: "C",
    fields: {
      quadrant: { value: 0b00, mask: 0b11 },
      funct3: { value: 0b000, mask: 0b111 < 13 },
      imm_value: { value: 0b00000000, mask: 0b11111111 << 5 },
      rd: { value: 0b000, mask: 0b111 << 2 },
    },
  },
  c_addi4spn: {
    ISA: "RV",
    assembly: ["rd", "nzuimm"],
    pseudocode: "addi rd' = sp + nzuimm = sp + 4*imm",
    description: "Compressed Add imm*4 to SP",
    type: "CIW",
    arch_width: ["RES"],
    extension: "C",
    fields: {
      quadrant: { value: 0b00, mask: 0b11 },
      funct3: { value: 0b000, mask: 0b111 < 13 },
      nzuimm: { mask: 0b11111111 << 5 },
      rd: { mask: 0b111 << 2 },
    },
  },
  c_fld: {
    ISA: "RV",
    assembly: ["rd", "rs1", "uimm"],
    pseudocode: "rd = M64[rs1 + uimm];",
    description: "Compressed Load Double Floating-Point",
    type: "CI",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b00, mask: 0b11 },
      funct3: { value: 0b001, mask: 0b111 << 13 },
      uimm1: { mask: 0b111 << 10 },
      uimm2: { mask: 0b11 << 5 },
      rs1: { mask: 0b111 << 7 },
      rd: { mask: 0b111 << 2 },
    },
  },
  c_lq: {
    ISA: "RV",
    assembly: ["rd", "rs1", "uimm"],
    pseudocode: "rd = M128[rs1 + uimm];",
    description: "Compressed Load Quadruple Floating-Point",
    type: "CIW",
    arch_width: [128],
    extension: "C",
    fields: {
      quadrant: { value: 0b00, mask: 0b11 },
      funct3: { value: 0b001, mask: 0b111 << 13 },
      uimm1: { mask: 0b11 << 11 },
      m1: { mask: 0b1 << 10 },
      uimm2: { mask: 0b11 << 5 },
      rs1: { mask: 0b111 << 7 },
      rd: { mask: 0b111 << 2 },
    },
  },
  c_lw: {
    ISA: "RV",
    assembly: ["rd", "rs1", "uimm"],
    pseudocode: "rd' <- M[ rs1' + offset ];",
    description: "Compressed Load Word",
    type: "CL",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b00, mask: 0b11 },
      funct3: { value: 0b010, mask: 0b111 << 13 },
      uimm: { mask: 0b111 << 10 },
      m2: { mask: 0b1 << 6 },
      m1: { mask: 0b1 << 5 },
      rs1: { mask: 0b111 << 7 },
      rd: { mask: 0b111 << 2 },
    },
  },
  c_flw: {
    ISA: "RV",
    assembly: ["rd", "rs1", "uimm"],
    pseudocode: "rd = M32[rs1 + uimm];",
    description: "Compressed Load Float",
    type: "CIW",
    arch_width: [32],
    extension: "C",
    fields: {
      quadrant: { value: 0b00, mask: 0b11 },
      funct3: { value: 0b011, mask: 0b111 << 13 },
      uimm: { mask: 0b111 << 10 },
      m2: { mask: 0b1 << 6 },
      m1: { mask: 0b1 << 5 },
      rs1: { mask: 0b111 << 7 },
      rd: { mask: 0b111 << 2 },
    },
  },
  c_ld: {
    ISA: "RV",
    assembly: ["rd", "rs1", "uimm"],
    pseudocode: "rd = M64[rs1 + uimm];",
    description: "Compressed Load Double",
    type: "CI",
    arch_width: [64, 128],
    extension: "C",
    fields: {
      quadrant: { value: 0b00, mask: 0b11 },
      funct3: { value: 0b011, mask: 0b111 << 13 },
      uimm1: { mask: 0b111 << 10 },
      uimm2: { mask: 0b11 << 5 },
      rs1: { mask: 0b111 << 7 },
      rd: { mask: 0b111 << 2 },
    },
  },
  c_fsd: {
    ISA: "RV",
    assembly: ["rs1", "rs2", "uimm"],
    pseudocode: "M64[rs1 + uimm] = rs2;",
    description: "Compressed Store Double Floating-Point",
    type: "CI",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b00, mask: 0b11 },
      funct3: { value: 0b101, mask: 0b111 << 13 },
      uimm1: { mask: 0b111 << 10 },
      uimm2: { mask: 0b11 << 5 },
      rs1: { mask: 0b111 << 7 },
      rs2: { mask: 0b111 << 2 },
    },
  },
  c_sq: {
    ISA: "RV",
    assembly: ["rs1", "rs2", "uimm"],
    pseudocode: "M128[rs1 + uimm] = rs2;",
    description: "Compressed Store Quadruple Floating-Point",
    type: "CI",
    arch_width: [128],
    extension: "C",
    fields: {
      quadrant: { value: 0b00, mask: 0b11 },
      funct3: { value: 0b101, mask: 0b111 << 13 },
      uimm1: { mask: 0b11 << 11 },
      m1: { mask: 0b1 << 10 },
      uimm2: { mask: 0b11 << 5 },
      rs1: { mask: 0b111 << 7 },
      rs2: { mask: 0b111 << 2 },
    },
  },
  c_sw: {
    ISA: "RV",
    assembly: ["rs1", "rs2", "uimm"],
    pseudocode: "M32[rs1 + uimm] = rs2;",
    description: "Compressed Store Word",
    type: "CS",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b00, mask: 0b11 },
      funct3: { value: 0b110, mask: 0b111 << 13 },
      uimm: { mask: 0b111 << 10 },
      m2: { mask: 0b1 << 6 },
      m1: { mask: 0b1 << 5 },
      rs1: { mask: 0b111 << 7 },
      rs2: { mask: 0b111 << 2 },
    },
  },
  c_fsw: {
    ISA: "RV",
    assembly: ["rs1", "rs2", "uimm"],
    pseudocode: "M32[rs1 + uimm] = rs2;",
    description: "Compressed Store Float",
    type: "CIW",
    arch_width: [32],
    extension: "C",
    fields: {
      quadrant: { value: 0b00, mask: 0b11 },
      funct3: { value: 0b111, mask: 0b111 << 13 },
      uimm: { mask: 0b111 << 10 },
      m2: { mask: 0b1 << 6 },
      m1: { mask: 0b1 << 5 },
      rs1: { mask: 0b111 << 7 },
      rs2: { mask: 0b111 << 2 },
    },
  },
  c_sd: {
    ISA: "RV",
    assembly: ["rs1", "rs2", "uimm"],
    pseudocode: "M64[rs1 + uimm] = rs2;",
    description: "Compressed Store Double",
    type: "CI",
    arch_width: [64, 128],
    extension: "C",
    fields: {
      quadrant: { value: 0b00, mask: 0b11 },
      funct3: { value: 0b111, mask: 0b111 << 13 },
      uimm1: { mask: 0b111 << 10 },
      uimm2: { mask: 0b11 << 5 },
      rs1: { mask: 0b111 << 7 },
      rs2: { mask: 0b111 << 2 },
    },
  },
  c_nop: {
    ISA: "RV",
    assembly: [],
    pseudocode: "",
    description: "Compressed No OPeration",
    type: "CI",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct3: { value: 0b000, mask: 0b111 << 13 },
      op_val: { value: 0b00000000000 << 2 },
    },
  },
  c_addi: {
    ISA: "RV",
    assembly: ["rd", "nzimm"],
    pseudocode: "rd = rd + sext(nzimm);",
    description: "Compressed Add Immediate",
    type: "CI",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct3: { value: 0b000, mask: 0b111 << 13 },
      m1: { mask: 0b1 << 12 },
      imm1: { mask: 0b11111 << 2 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  c_jal: {
    ISA: "RV",
    assembly: ["imm", "rd"],
    pseudocode: "rd = PC + sext(imm);",
    description: "Compressed Jump and Link",
    type: "CJ",
    arch_width: [32,64],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct3: { value: 0b001, mask: 0b111 << 13 },
      m1: { mask: 0b1 << 12 },
      m2: { mask: 0b1 << 11 },
      imm2: { mask: 0b11 << 9 },
      m3: { mask: 0b1 << 8 },
      m4: { mask: 0b1 << 7 },
      m5: { mask: 0b1 << 6 },
      imm1: { mask: 0b111 << 3 },
      m6: { mask: 0b1 << 2 },
    },
  },
  c_addiw: {
    ISA: "RV",
    assembly: ["rd", "nzimm"],
    pseudocode: "rd = rd + sext(nzimm);",
    description: "Compressed Add Immediate Word",
    type: "CW",
    arch_width: [64, 128],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct3: { value: 0b001, mask: 0b111 << 13 },
      m1: { mask: 0b1 << 12 },
      imm1: { mask: 0b11111 << 2 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  c_li: {
    ISA: "RV",
    assembly: ["rd", "imm"],
    pseudocode: "rd = sext(imm);",
    description: "Compressed Load Immediate",
    type: "CI",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct3: { value: 0b010, mask: 0b111 << 13 },
      m1: { mask: 0b1 << 12 },
      imm1: { mask: 0b11111 << 2 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  c_addi16sp: {
    ISA: "RV",
    assembly: ["nzuimm"],
    pseudocode: "sp = sp + sext(nzuimm);",
    description: "Compressed Add Immediate to SP",
    type: "CI",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct3: { value: 0b011, mask: 0b111 << 13 },
      nzuimm5: { mask: 0b1 << 12 },
      nzuimm2: { mask: 0b11 << 3 },
      nzuimm1: { mask: 0b1 << 2 },
      nzuimm3: { mask: 0b1 << 5 },
      nzuimm4: { mask: 0b1 << 6 },
      rd: { value: 0b10, mask: 0b11111 << 7 },
    },
  },
  c_lui: {
    ISA: "RV",
    assembly: ["rd", "nzimm"],
    pseudocode: "rd = imm << 12 (zero extends);",
    description: "Compressed Load Upper Immediate",
    type: "CI",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct3: { value: 0b011, mask: 0b111 << 13 },
      imm1: { mask: 0b11111 << 2 },
      m1: { mask: 0b1 << 12 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  c_srli: {
    ISA: "RV",
    assembly: ["rd", "nzuimm", "rs1"],
    pseudocode: "rd = rd (zero)>> shamt;",
    description: "Compressed Shift Right Logical Immediate",
    type: "CB",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct6: { value: 0b100000, mask: 0b111111 << 10 },
      nzuimm: { mask: 0b11111 << 2 },
      rd: { mask: 0b111 << 7 },
    },
  }, // SRLI64
  c_srai: {
    ISA: "RV",
    assembly: ["rd", "nzuimm", "rs1"],
    pseudocode: "rd = rd (msb)>> nzuimm;",
    description: "Compressed Shift Right Arithmetic Immediate",
    type: "CB",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct6: { value: 0b100001, mask: 0b111111 << 10 },
      nzuimm: { mask: 0b11111 << 2 },
      rd: { mask: 0b111 << 7 },
    },
  }, // SRAI64
  c_andi: {
    ISA: "RV",
    assembly: ["rd", "imm"],
    pseudocode: "rd &= imm;",
    description: "Compressed AND Immediate",
    type: "CB",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct3: { value: 0b100, mask: 0b111 << 13 },
      funct2: { value: 0b10, mask: 0b11 << 10 },
      m1: { mask: 0b1 << 12 },
      imm1: { mask: 0b11111 << 2 },
      rd: { mask: 0b111 << 7 },
    },
  },
  c_sub: {
    ISA: "RV",
    assembly: ["rd", "rs2"],
    pseudocode: "rd' -= rs';",
    description: "Compressed Subtract",
    type: "CA",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct6: { value: 0b100011, mask: 0b111111 << 10 },
      funct2: { value: 0b00, mask: 0b11 << 5 },
      rs2: { mask: 0b111 << 2 },
      rd: { mask: 0b111 << 7 },
    },
  },
  c_xor: {
    ISA: "RV",
    assembly: ["rd", "rs2"],
    pseudocode: "rd' ^= rs';",
    description: "Compressed XOR",
    type: "CA",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct6: { value: 0b100011, mask: 0b111111 << 10 },
      funct2: { value: 0b01, mask: 0b11 << 5 },
      rs2: { mask: 0b111 << 2 },
      rd: { mask: 0b111 << 7 },
    },
  },
  c_or: {
    ISA: "RV",
    assembly: ["rd", "rs2"],
    pseudocode: "rd' |= rs';",
    description: "Compressed OR",
    type: "CA",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct6: { value: 0b100011, mask: 0b111111 << 10 },
      funct2: { value: 0b10, mask: 0b11 << 5 },
      rs2: { mask: 0b111 << 2 },
      rd: { mask: 0b111 << 7 },
    },
  },
  c_and: {
    ISA: "RV",
    assembly: ["rd", "rs2", "rs1"],
    pseudocode: "rd = rd & rs;",
    description: "Compressed AND",
    type: "CA",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct6: { value: 0b100011, mask: 0b111111 << 10 },
      funct2: { value: 0b11, mask: 0b11 << 5 },
      rs2: { mask: 0b111 << 2 },
      rd: { mask: 0b111 << 7 },
    },
  },
  c_subw: {
    ISA: "RV",
    assembly: ["rd", "rs2"],
    pseudocode: "rd = rd - rs2;",
    description: "Compressed Subtract Word",
    type: "CA",
    arch_width: [64, 128, "RES"],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct6: { value: 0b100111, mask: 0b111111 << 10 },
      funct2: { value: 0b00, mask: 0b11 << 5 },
      rs2: { mask: 0b111 << 2 },
      rd: { mask: 0b111 << 7 },
    },
  },
  c_addw: {
    ISA: "RV",
    assembly: ["rd", "rs2"],
    pseudocode: "rd = rd + rs2;",
    description: "Compressed Add Word",
    type: "CA",
    arch_width: [64, 128, "RES"],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct6: { value: 0b100111, mask: 0b111111 << 10 },
      funct2: { value: 0b01, mask: 0b11 << 5 },
      rs2: { mask: 0b111 << 2 },
      rd: { mask: 0b111 << 7 },
    },
  },
  c_reserved1: {
    ISA: "RV",
    assembly: [],
    pseudocode: "",
    description: "Reserved",
    type: "CR",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct6: { value: 0b100111, mask: 0b111111 << 10 },
      funct2: { value: 0b10, mask: 0b11 << 5 },
    },
  },
  c_reserved2: {
    ISA: "RV",
    assembly: [],
    pseudocode: "",
    description: "Reserved",
    type: "CR",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct6: { value: 0b100111, mask: 0b111111 << 10 },
      funct2: { value: 0b11, mask: 0b11 << 5 },
    },
  },
  c_j: {
    ISA: "RV",
    assembly: ["imm"],
    pseudocode: "PC += sext(imm);",
    description: "Compressed Jump",
    type: "CJ",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct3: { value: 0b101, mask: 0b111 << 13 },
      m1: { mask: 0b1 << 12 },
      m2: { mask: 0b1 << 11 },
      imm2: { mask: 0b11 << 9 },
      m3: { mask: 0b1 << 8 },
      m4: { mask: 0b1 << 7 },
      m5: { mask: 0b1 << 6 },
      imm1: { mask: 0b111 << 3 },
      m6: { mask: 0b1 << 2 },
    },
  },
  c_beqz: {
    ISA: "RV",
    assembly: ["rs1", "imm"],
    pseudocode: "if (rs1 == 0) PC += sext(imm);",
    description: "Compressed Branch if Equal to Zero",
    type: "CB",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct3: { value: 0b110, mask: 0b111 << 13 },
      imm1: { mask: 0b11 << 3 },
      imm2: { mask: 0b11 << 5 },
      imm3: { mask: 0b11 << 10 },
      m1: { mask: 0b1 << 12 },
      m2: { mask: 0b1 << 2 },
      rs1: { mask: 0b111 << 7 },
    },
  },
  c_bnez: {
    ISA: "RV",
    assembly: ["rs1", "imm"],
    pseudocode: "if (rs1 != 0) PC += sext(imm);",
    description: "Compressed Branch if Not Equal to Zero",
    type: "CB",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b01, mask: 0b11 },
      funct3: { value: 0b111, mask: 0b111 << 13 },
      imm1: { mask: 0b11 << 3 },
      imm2: { mask: 0b11 << 5 },
      imm3: { mask: 0b11 << 10 },
      m1: { mask: 0b1 << 12 },
      m2: { mask: 0b1 << 2 },
      rs1: { mask: 0b111 << 7 },
    },
  },
  c_slli: {
    ISA: "RV",
    assembly: ["rd", "nzuimm"],
    pseudocode: "rd = rs1 << nzuimm;",
    description: "Compressed Shift Left Logical Immediate",
    type: "CI",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b10, mask: 0b11 },
      funct3: { value: 0b000, mask: 0b111 << 13 },
      nzuimm: { mask: 0b11111 << 2 },
      m1: { mask: 0b1 << 12 },
      rs1: { mask: 0b11111 << 7 },
    },
  }, // SLLI64
  c_fldsp: {
    ISA: "RV",
    assembly: ["rd", "uimm"],
    pseudocode: "rd = M[sp + uimm];",
    description: "Compressed Load Doubleword from SP",
    type: "CL",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b10, mask: 0b11 },
      funct3: { value: 0b001, mask: 0b111 << 13 },
      m1: { mask: 0b1 << 12 },
      uimm2: { mask: 0b111 << 2 },
      uimm1: { mask: 0b11 << 5 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  c_lqsp: {
    ISA: "RV",
    assembly: ["rd", "uimm"],
    pseudocode: "rd = M[sp + uimm];",
    description: "Compressed Load Quadrupleword from SP",
    type: "CL",
    arch_width: [128, "RES"],
    extension: "C",
    fields: {
      quadrant: { value: 0b10, mask: 0b11 },
      funct3: { value: 0b001, mask: 0b111 << 13 },
      uimm1: { mask: 0b1111 << 2 },
      m1: { mask: 0b1 << 12 },
      m2: { mask: 0b1 << 6 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  c_lwsp: {
    ISA: "RV",
    assembly: ["rd", "uimm"],
    pseudocode: "rd = M[sp + uimm];",
    description: "Compressed Load Word from SP",
    type: "CL",
    arch_width: ["RES"],
    extension: "C",
    fields: {
      quadrant: { value: 0b10, mask: 0b11 },
      funct3: { value: 0b010, mask: 0b111 << 13 },
      m1: { mask: 0b1 << 12 },
      uimm2: { mask: 0b111 << 2 },
      uimm1: { mask: 0b11 << 5 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  c_flwsp: {
    ISA: "RV",
    assembly: ["rd", "uimm"],
    pseudocode: "rd = M[sp + uimm];",
    description: "Compressed Load Float from SP",
    type: "CL",
    arch_width: [32],
    extension: "C",
    fields: {
      quadrant: { value: 0b10, mask: 0b11 },
      funct3: { value: 0b011, mask: 0b111 << 13 },
      m1: { mask: 0b1 << 12 },
      uimm2: { mask: 0b111 << 2 },
      uimm1: { mask: 0b11 << 5 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  c_ldsp: {
    ISA: "RV",
    assembly: ["rd", "uimm"],
    pseudocode: "rd = M[sp + uimm];",
    description: "Compressed Load Double from SP",
    type: "CL",
    arch_width: [64, 128],
    extension: "C",
    fields: {
      quadrant: { value: 0b10, mask: 0b11 },
      funct3: { value: 0b011, mask: 0b111 << 13 },
      m1: { mask: 0b1 << 12 },
      uimm2: { mask: 0b111 << 2 },
      uimm1: { mask: 0b11 << 5 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  c_jr: {
    ISA: "RV",
    assembly: ["rd", "rs1"],
    pseudocode: "PC = rs1;",
    description: "Compressed Jump Register",
    type: "CR",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b10, mask: 0b11 },
      funct4: { value: 0b1000, mask: 0b1111 << 12 },
      rs2: { value: 0b00000, mask: 0b11111 << 2 },
      rs1: { mask: 0b11111 << 7 },
    },
  },
  c_mv: {
    ISA: "RV",
    assembly: ["rd", "rs2"],
    pseudocode: "rd = rs2;",
    description: "Compressed Move",
    type: "CR",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b10, mask: 0b11 },
      funct4: { value: 0b1000, mask: 0b1111 << 12 },
      rs2: { mask: 0b11111 << 2 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  c_ebreak: {
    ISA: "RV",
    assembly: [],
    pseudocode: "Breakpoint",
    description: "Compressed EBREAK",
    type: "CR",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b10, mask: 0b11 },
      funct4: { value: 0b1001, mask: 0b1111 << 12 },
      rs2: { value: 0b00000, mask: 0b11111 << 2 },
      rd: { value: 0b00000, mask: 0b11111 << 7 },
    },
  },
  c_jalr: {
    ISA: "RV",
    assembly: ["rs1"],
    pseudocode: "rd = PC + 2; PC = rs;",
    description: "Compressed Jump and Link Register",
    type: "CR",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b10, mask: 0b11 },
      funct4: { value: 0b1001, mask: 0b1111 << 12 },
      rs2: { value: 0b00000, mask: 0b11111 << 2 },
      rs1: { mask: 0b11111 << 7 },
    },
  },
  c_add: {
    ISA: "RV",
    assembly: ["rd", "rs2"],
    pseudocode: "rd += rs;",
    description: "Compressed Add",
    type: "CR",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b10, mask: 0b11 },
      funct4: { value: 0b1001, mask: 0b1111 << 12 },
      rs2: { mask: 0b11111 << 2 },
      rd: { mask: 0b11111 << 7 },
    },
  },
  c_fsdsp: {
    ISA: "RV",
    assembly: ["rs2", "uimm"],
    pseudocode: "M[sp + uimm] = rs2;",
    description: "Compressed Store Double from SP",
    type: "CS",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b10, mask: 0b11 },
      funct3: { value: 0b101, mask: 0b111 << 13 },
      uimm1: { mask: 0b111 << 10 },
      uimm2: { mask: 0b111 << 7 },
      rs2: { mask: 0b11111 << 2 },
    },
  },
  c_sqsp: {
    ISA: "RV",
    assembly: ["rs2", "uimm"],
    pseudocode: "M[sp + uimm] = rs2;",
    description: "Compressed Store Quadruple from SP",
    type: "CS",
    arch_width: [128],
    extension: "C",
    fields: {
      quadrant: { value: 0b10, mask: 0b11 },
      funct3: { value: 0b101, mask: 0b111 << 13 },
      uimm1: { mask: 0b11 << 11 },
      uimm2: { mask: 0b1111 << 7 },
      rs2: { mask: 0b11111 << 2 },
    },
  },
  c_swsp: {
    ISA: "RV",
    assembly: ["rs2", "uimm"],
    pseudocode: "M[sp + uimm] = rs2;",
    description: "Compressed Store Word from SP",
    type: "CSS",
    arch_width: [32, 64],
    extension: "C",
    fields: {
      quadrant: { value: 0b10, mask: 0b11 },
      funct3: { value: 0b110, mask: 0b111 << 13 },
      uimm2: { mask: 0b1111 << 9 },
      uimm1: { mask: 0b11 << 7 },
      rs2: { mask: 0b11111 << 2 },
    },
  },
  c_fswsp: {
    ISA: "RV",
    assembly: ["rs2", "uimm"],
    pseudocode: "M[sp + uimm] = rs2;",
    description: "Compressed Store Float from SP",
    type: "CSS",
    arch_width: [32],
    extension: "C",
    fields: {
      quadrant: { value: 0b10, mask: 0b11 },
      funct3: { value: 0b111, mask: 0b111 << 13 },
      uimm2: { mask: 0b1111 << 9 },
      uimm1: { mask: 0b11 << 7 },
      rs2: { mask: 0b11111 << 2 },
    },
  },
  c_sdsp: {
    ISA: "RV",
    assembly: ["rs2", "uimm"],
    pseudocode: "M[sp + uimm] = rs2;",
    description: "Compressed Store Double from SP",
    type: "CSS",
    arch_width: [64, 128],
    extension: "C",
    fields: {
      quadrant: { value: 0b10, mask: 0b11 },
      funct3: { value: 0b111, mask: 0b111 << 13 },
      uimm1: { mask: 0b111 << 10 },
      uimm2: { mask: 0b111 << 7 },
      rs2: { mask: 0b11111 << 2 },
    },
  },
};

// Done: RV[32/64]G+C
// TO-DO: RV[32/64]C
